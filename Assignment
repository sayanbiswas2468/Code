
#include <stdio.h>
#include <stdlib.h>


typedef struct node {
	int data;

	
	int priority;

	struct node* next;

} Node;


Node* newNode(int d, int p)
{
	Node* temp = (Node*)malloc(sizeof(Node));
	temp->data = d;
	temp->priority = p;
	temp->next = NULL;

	return temp;
}


int peek(Node** head)
{
	return (*head)->data;
}


void pop(Node** head)
{
	Node* temp = *head;
	(*head) = (*head)->next;
	free(temp);
}


void push(Node** head, int d, int p)
{
	Node* start = (*head);

	
	Node* temp = newNode(d, p);


	if ((*head)->priority > p) {

		
		temp->next = *head;
		(*head) = temp;
	}
	else {

		
		while (start->next != NULL &&
			start->next->priority < p) {
			start = start->next;
		}

		
		temp->next = start->next;
		start->next = temp;
	}
}


int isEmpty(Node** head)
{
	return (*head) == NULL;
}


int main()
{

	Node* pq = newNode(4, 1);
	push(&pq, 5, 2);
	push(&pq, 6, 3);
	push(&pq, 7, 0);

	while (!isEmpty(&pq)) {
		printf("%d ", peek(&pq));
		pop(&pq);
	}

	return 0;
}

















PUSH(HEAD, DATA, PRIORITY) 
Step 1: Create new node with DATA and PRIORITY 
Step 2: Check if HEAD has lower priority. If true follow Steps 3-4 and end. Else goto Step 5. 
Step 3: NEW -> NEXT = HEAD 
Step 4: HEAD = NEW 
Step 5: Set TEMP to head of the list 
Step 6: While TEMP -> NEXT != NULL and TEMP -> NEXT -> PRIORITY > PRIORITY 
Step 7: TEMP = TEMP -> NEXT 
[END OF LOOP] 
Step 8: NEW -> NEXT = TEMP -> NEXT 
Step 9: TEMP -> NEXT = NEW 
Step 10: End
POP(HEAD) 
Step 2: Set the head of the list to the next node in the list. HEAD = HEAD -> NEXT. 
Step 3: Free the node at the head of the list 
Step 4: End
PEEK(HEAD): 
Step 1: Return HEAD -> DATA 
Step 2: End

